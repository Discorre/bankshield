{"ast":null,"code":"// api.js\nimport axios from 'axios';\nconst api = axios.create({\n  baseURL: 'http://localhost:8000'\n});\n\n// Флаг, чтобы не запускать несколько обновлений одновременно\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\n\n// Перехватчик ответа\napi.interceptors.response.use(res => res, async error => {\n  var _error$response;\n  const originalRequest = error.config;\n\n  // Если access_token истёк\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    if (isRefreshing) {\n      return new Promise(function (resolve, reject) {\n        failedQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers['Authorization'] = `Bearer ${token}`;\n        return axios(originalRequest);\n      }).catch(err => Promise.reject(err));\n    }\n    isRefreshing = true;\n    try {\n      const refreshToken = localStorage.getItem('refreshToken');\n      const response = await axios.post('http://localhost:8000/refresh', {}, {\n        headers: {\n          'refresh_token': refreshToken\n        }\n      });\n      const newAccessToken = response.data.access_token;\n      localStorage.setItem('accessToken', newAccessToken);\n      api.defaults.headers.common['Authorization'] = `Bearer ${newAccessToken}`;\n      processQueue(null, newAccessToken);\n      originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;\n      return api(originalRequest);\n    } catch (err) {\n      processQueue(err, null);\n      return Promise.reject(err);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  return Promise.reject(error);\n});\n\n// Добавим access токен к каждому запросу\napi.interceptors.request.use(config => {\n  const token = localStorage.getItem('accessToken');\n  if (token) {\n    config.headers['Authorization'] = `Bearer ${token}`;\n  }\n  return config;\n}, error => Promise.reject(error));\nexport default api;","map":{"version":3,"names":["axios","api","create","baseURL","isRefreshing","failedQueue","processQueue","error","token","forEach","prom","reject","resolve","interceptors","response","use","res","_error$response","originalRequest","config","status","_retry","Promise","push","then","headers","catch","err","refreshToken","localStorage","getItem","post","newAccessToken","data","access_token","setItem","defaults","common","request"],"sources":["/home/discorre/vscodeproj/123/bankshield/bankshield-client/src/api/api.js"],"sourcesContent":["// api.js\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: 'http://localhost:8000',\n});\n\n// Флаг, чтобы не запускать несколько обновлений одновременно\nlet isRefreshing = false;\nlet failedQueue = [];\n\nconst processQueue = (error, token = null) => {\n  failedQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedQueue = [];\n};\n\n// Перехватчик ответа\napi.interceptors.response.use(\n  res => res,\n  async error => {\n    const originalRequest = error.config;\n\n    // Если access_token истёк\n    if (error.response?.status === 401 && !originalRequest._retry) {\n      originalRequest._retry = true;\n\n      if (isRefreshing) {\n        return new Promise(function (resolve, reject) {\n          failedQueue.push({ resolve, reject });\n        }).then(token => {\n          originalRequest.headers['Authorization'] = `Bearer ${token}`;\n          return axios(originalRequest);\n        }).catch(err => Promise.reject(err));\n      }\n\n      isRefreshing = true;\n\n      try {\n        const refreshToken = localStorage.getItem('refreshToken');\n        const response = await axios.post('http://localhost:8000/refresh', {}, {\n          headers: {\n            'refresh_token': refreshToken,\n          },\n        });\n\n        const newAccessToken = response.data.access_token;\n        localStorage.setItem('accessToken', newAccessToken);\n\n        api.defaults.headers.common['Authorization'] = `Bearer ${newAccessToken}`;\n        processQueue(null, newAccessToken);\n\n        originalRequest.headers['Authorization'] = `Bearer ${newAccessToken}`;\n        return api(originalRequest);\n      } catch (err) {\n        processQueue(err, null);\n        return Promise.reject(err);\n      } finally {\n        isRefreshing = false;\n      }\n    }\n\n    return Promise.reject(error);\n  }\n);\n\n// Добавим access токен к каждому запросу\napi.interceptors.request.use(\n  config => {\n    const token = localStorage.getItem('accessToken');\n    if (token) {\n      config.headers['Authorization'] = `Bearer ${token}`;\n    }\n    return config;\n  },\n  error => Promise.reject(error)\n);\n\nexport default api;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}